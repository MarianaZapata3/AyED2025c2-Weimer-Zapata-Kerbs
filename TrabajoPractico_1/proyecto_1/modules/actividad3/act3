# Prueba Act 3 – Burbuja, Quicksort, Radix + comparación con sorted()

import random
import time
import matplotlib.pyplot as plt

# -------------------------
# Burbuja (in-place funcional: devuelve nueva lista)
# -------------------------
def ordenamiento_burbuja(lst):
    a = lst[:]  # no modificar la original
    n = len(a)
    for i in range(n - 1):
        hubo_swap = False
        for j in range(0, n - i - 1):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                hubo_swap = True
        if not hubo_swap:  # optimización: si no hubo swaps, ya está ordenada
            break
    return a

# -------------------------
# Quicksort (funcional)
# -------------------------
def quicksort(lst):
    if len(lst) <= 1:
        return lst[:]
    pivote = lst[len(lst) // 2]
    menores = [x for x in lst if x < pivote]
    iguales = [x for x in lst if x == pivote]
    mayores = [x for x in lst if x > pivote]
    return quicksort(menores) + iguales + quicksort(mayores)

# -------------------------
# Radix Sort (LSD, base 10), entero no negativo
# -------------------------
def _counting_sort_por_exp(a, exp):
    n = len(a)
    salida = [0] * n
    conteo = [0] * 10  # dígitos 0..9

    # contar
    for num in a:
        conteo[(num // exp) % 10] += 1

    # acumulado
    for i in range(1, 10):
        conteo[i] += conteo[i - 1]

    # construir salida (de derecha a izquierda para estabilidad)
    for i in range(n - 1, -1, -1):
        d = (a[i] // exp) % 10
        salida[conteo[d] - 1] = a[i]
        conteo[d] -= 1

    return salida

def radix_sort(lst):
    if not lst:
        return []
    a = lst[:]
    maximo = max(a)
    exp = 1
    while maximo // exp > 0:
        a = _counting_sort_por_exp(a, exp)
        exp *= 10
    return a

# -------------------------
# Verificación de corrección con 500 números de 5 dígitos
# -------------------------
def probar_correctitud():
    datos = [random.randint(10000, 99999) for _ in range(500)]
    esperado = sorted(datos)
    assert ordenamiento_burbuja(datos) == esperado
    assert quicksort(datos) == esperado
    assert radix_sort(datos) == esperado
    print("✔️ Todos los algoritmos ordenan correctamente listas de 5 dígitos (500 elems).")

# -------------------------
# Medición y gráfico
# -------------------------
def medir_y_graficar():
    tamanios = list(range(100, 1001, 100))  # 100..1000
    tiempos_burbuja, tiempos_quick, tiempos_radix, tiempos_sorted = [], [], [], []

    for n in tamanios:
        lista = [random.randint(10000, 99999) for _ in range(n)]

        t0 = time.perf_counter()
        ordenamiento_burbuja(lista)
        tiempos_burbuja.append(time.perf_counter() - t0)

        t0 = time.perf_counter()
        quicksort(lista)
        tiempos_quick.append(time.perf_counter() - t0)

        t0 = time.perf_counter()
        radix_sort(lista)
        tiempos_radix.append(time.perf_counter() - t0)

        t0 = time.perf_counter()
        sorted(lista)
        tiempos_sorted.append(time.perf_counter() - t0)

    # Graficar (una sola figura, sin estilos ni colores custom)
    plt.plot(tamanios, tiempos_burbuja, marker='o', label="Burbuja (O(n²))")
    plt.plot(tamanios, tiempos_quick, marker='o', label="Quicksort (O(n log n))")
    plt.plot(tamanios, tiempos_radix, marker='o', label="Radix (O(d·n))")
    plt.plot(tamanios, tiempos_sorted, marker='o', label="sorted() (Timsort)")

    plt.xlabel("Tamaño de la lista")
    plt.ylabel("Tiempo (segundos)")
    plt.title("Comparación de tiempos de ordenamiento (5 dígitos)")
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    probar_correctitud()
    medir_y_graficar()
